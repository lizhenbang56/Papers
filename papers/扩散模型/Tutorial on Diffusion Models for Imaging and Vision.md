---
论文链接: https://arxiv.org/pdf/2403.18103.pdf
---
## Abstract

近年来生成工具的惊人增长使得许多令人兴奋的应用在文本到图像生成和文本到视频生成方面得以实现。这些生成工具背后的基本原理是扩散的概念，这是一种特定的采样机制，已经克服了以前方法中被认为难以解决的一些缺点。本教程的目标是讨论扩散模型的基本思想。本教程的目标受众包括对扩散模型进行研究或将这些模型应用于解决其他问题感兴趣的本科生和研究生。

## 1 The Basics: Variational Auto-Encoder (VAE)

### 1.1 VAE Setting

很久以前，我们想要建立一个从 latent code 生成图像的生成器。最简单（也可能是最经典的）方法是考虑下面显示的编码器-解码器对。这被称为变分自动编码器（VAE）[1, 2, 3]。

自动编码器具有输入变量 x 和潜在变量 z。为了更好地理解这个主题，我们将 x 视为一幅美丽的图像，将 z 视为存在于某个高维空间中的某种类型的向量。

“变分”这个名字来自于我们使用概率分布来描述 x 和 z。与其采用将 x 转换为 z 的确定性过程不同，我们更感兴趣的是确保分布 p(x) 能够映射到一个期望的分布 p(z)，然后再反向到 p(x)。由于分布的设置，我们需要考虑一些分布。

- p(x)：x 的分布。它是未知的。如果我们知道它，我们早就成为亿万富翁了。扩散模型的整个星系都是为了找到从 p(x) 中抽取样本的方法。
- p(z)：潜在变量的分布。因为我们都很懒，让我们把它设为零均值单位方差的高斯分布 p(z) = N(0, I)。
- p(z|x)：与编码器相关的条件分布，告诉我们在给定 x 时 z 的可能性。我们无法访问它。p(z|x) 本身不是编码器，但编码器必须做一些事情，以使其与 p(z|x) 一致。
- p(x|z)：与解码器相关的条件分布，告诉我们在给定 z 时得到 x 的后验概率。同样，我们无法访问它。

上述四个分布并不神秘。下面是一个略显琐碎但富有教育意义的例子，可以说明这个概念。

像您这样聪明的读者肯定会抱怨：“你的例子太琐碎而不真实了。”别担心。我们理解。生活当然比已知均值和已知方差的高斯混合模型要困难得多。但我们意识到的一件事是，如果我们想要找到神奇的编码器和解码器，我们必须有一种方法来找到这两个条件分布。然而，它们都是高维生物。因此，为了能够说出更有意义的东西，我们需要施加额外的结构，以便将这个概念推广到更难的问题中。

在变分自动编码器的文献中，人们提出了考虑以下两个代理分布的想法：

- qϕ(z|x)：p(z|x)的代理。我们将其设为高斯分布。为什么是高斯分布？没有特别好的理由。也许我们只是普通（也就是懒惰）的人类。
- pθ(x|z)：p(x|z)的代理。信不信由你，我们也会将其设为高斯分布。但是，这个高斯分布的角色与高斯分布 qϕ(z|x) 稍有不同。虽然我们需要估计高斯分布 qϕ(z|x) 的均值和方差，但我们不需要为高斯分布 pθ(x|z) 估计任何东西。相反，我们将需要一个解码器神经网络将 z 转换为 x。高斯分布 pθ(x|z) 将用于告诉我们生成的图像 x 有多好。

输入 x 与潜在 z 之间的关系，以及条件分布，总结如图1所示。有两个节点 x 和 z。 “正向”关系由 p(z|x)（由 qϕ(z|x) 近似）指定，而 “逆向” 关系由 p(x|z)（由 pθ(x|z) 近似）指定。

## 2 Denoising Diffusion Probabilistic Model (DDPM)

这段文字讨论的是由 Ho 等人提出的 DDPM [4]。如果你被网上成千上万的教程搞糊涂了，请放心，DDPM 并没有那么复杂。你只需要理解以下几点总结:

扩散模型是增量更新的过程，整体的组装为我们提供了编码器-解码器结构。从一个状态到另一个状态的转换由一个去噪器实现。为什么是增量更新？这就像改变一艘巨轮的方向。你需要慢慢地将船转向你想要的方向，否则你将失去控制。同样的原则也适用于你的生活、公司人力资源、大学行政部门、配偶、孩子以及你周围的一切。“一次只弯曲一英寸！” (感谢 Sergio Goma 在 2023 年电子成像会议上发表的评论)

扩散模型的结构如下，它被称为变分扩散模型 [5]。变分扩散模型由一系列状态组成：x0, x1, ..., xT：

- x0: 原始图像，与 VAE 中的 x 相同。
- xT: 潜在变量，与 VAE 中的 z 相同。由于我们都比较偷懒，所以我们希望 xT ∼ N(0, I)。
- x1, ..., xT-1: 中间状态。它们也是潜在变量，但不是白色高斯噪声。

变分扩散模型的结构如图 7 所示。正向路径和反向路径类似于单步变分自编码器的路径。区别在于编码器和解码器具有相同的输入输出维度。所有向前构建块的组装将给我们编码器，所有向后构建块的组装将给我们解码器。

### 2.1 Building Blocks

